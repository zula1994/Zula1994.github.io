import{_ as n,a as s,I as e,b as t,f as l,aw as d,E as a,o as c}from"./chunks/framework.Z4-7JWeT.js";const g=JSON.parse('{"title":"CDN 缓存","description":"","frontmatter":{"cdate":"2023-03-01T00:00:00.000Z","tags":["网络服务"],"cssclasses":["max"],"comment":true},"headers":[],"relativePath":"笔记/🛠️ 开发/cdn.md","filePath":"笔记/🛠️ 开发/cdn.md"}'),p={name:"笔记/🛠️ 开发/cdn.md"},h=t("h1",{id:"cdn-缓存",tabindex:"-1"},[l("CDN 缓存 "),t("a",{class:"header-anchor",href:"#cdn-缓存","aria-label":'Permalink to "CDN 缓存"'},"​")],-1),u=d('<h2 id="cdn" tabindex="-1">CDN <a class="header-anchor" href="#cdn" aria-label="Permalink to &quot;CDN&quot;">​</a></h2><h3 id="cdn-的概念" tabindex="-1">CDN 的概念 <a class="header-anchor" href="#cdn-的概念" aria-label="Permalink to &quot;CDN 的概念&quot;">​</a></h3><p>全称是 Content Delivery Network，即内容分发网络。CDN 是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。</p><h3 id="cdn-静态资源和动态资源的加速" tabindex="-1">CDN 静态资源和动态资源的加速 <a class="header-anchor" href="#cdn-静态资源和动态资源的加速" aria-label="Permalink to &quot;CDN 静态资源和动态资源的加速&quot;">​</a></h3><ul><li>静态资源</li></ul><p>网站的图片、视频、软件安装包、各类下载资源文件等变化较小的文件。</p><p>使用 CDN 加速可改善网站性能</p><ul><li>动态资源</li></ul><p>区别于静态资源，动态资源则更倾向于接口、个性化内容，用户每次请求得到的结果可能不同，这些资源并不适合 CDN 场景，如果强行使用会带来数据更新缓慢和不一致问题，但是动态资源有其特有的加速方法。 动态资源就意味着回源站进行数据请求，这其中就涉及到最优回源路径的选择，让路更好走，数据获取更快捷，实现动态资源的加速。</p><h2 id="缓存" tabindex="-1">缓存 <a class="header-anchor" href="#缓存" aria-label="Permalink to &quot;缓存&quot;">​</a></h2><h3 id="强缓存" tabindex="-1">强缓存 <a class="header-anchor" href="#强缓存" aria-label="Permalink to &quot;强缓存&quot;">​</a></h3><p>客户端第一次访问服务端资源时，服务端会返回请求的对应资源，告诉客户端将这个资源保存在本地，并且告诉客户端如果在未来的某个时间点之前还访问这个资源，则直接从本地获取就好，不需要再向服务端请求。 服务端在返回对应资源时，同时也返回了 Expires/Cache-Control 两个字段</p><ul><li>Expires</li></ul><p>为一个绝对时间的 GMT 格式的时间字符串，代表<mark>缓存资源的过期时间</mark>，在这个时间点之前访问，则命中缓存 缺点是该字段是根据客户端本地的时间进行对比的，若本地的时间与服务端的时间不一致，则会造成资源混乱 具体的请求过程为：</p><p>浏览器第一次发起请求后，response 响应头会携带 Expires，并将资源和 response header 保存在本地 当浏览器再次发起请求获取这个资源时，浏览器会先从缓存中找到这个资源，并对比 Expires 时间和本地当前请求的时间比较，若还没有超过 Expires 时间，则说明缓存未过期，即命中缓存；反之则重新发起请求获取资源，并重复以上操作</p><ul><li>Cache-Control 有很多属性</li></ul><p>private：客户端可以缓存 public：客户端和代理服务器都可以缓存 max-age=t：缓存将在 t 秒后失效（与 Expires 的时间格式不一样，这里主要为秒，表示第一次获取该资源后的 t 秒内该资源都被认为命中缓存） no-cache：需要使用协商缓存来验证缓存数据 no-store：所有内容都不会缓存</p><p>其描述的是相对时间，采用本地时间计算资源的有效期，即本地时间 + max-age，在这段时间内即命中缓存，所以比 Expires 更可靠 并且 Cache-Control 比 Expires 优先级更高</p><h3 id="协商缓存" tabindex="-1">协商缓存 <a class="header-anchor" href="#协商缓存" aria-label="Permalink to &quot;协商缓存&quot;">​</a></h3><p>客户端第一次访问服务端资源时，服务端会返回请求的对应资源和资源的一些信息<mark>（文件摘要/最后的修改时间）</mark>，告诉客户端将这个资源保存在本地，当客户端再次请求这个资源时，会将文件摘要/最后的修改时间一并发给服务端，由服务端判断客户端资源是否需要更新，若不需要更新，则直接告诉客户端从本地读取资源（返回状态码 304），若需要更新，则将最新的资源（包括最新的文件摘要/最后的修改时间）返回给客户端</p><ul><li>最后的修改时间（Last-Modified）</li></ul><p>Last-Modified：资源的最后修改时间 if-Modified-Since：通过比较两个时间来判断资源在两次请求期间是否有过修改，如果没有修改，则命中协商缓存，浏览器从缓存中获取资源；如果有过修改，则服务器返回资源，同时返回新的 Last-Modified 时间 具体请求过程</p><p>客户端第一次访问服务端资源时，服务端会返回请求的对应资源，并在响应头加上 Last-Modified 字段，表示这个资源再服务端上最后一次修改时间 当客户端再次请求该资源时，会在请求头加上 if-Modified-Since，这个值为上一次服务端返回的 Last-Modiffied 时间 当服务端收到请求时，会将 if-Modified-Since 的时间和服务端资源的最后修改时间进行对比，若一致，则命中缓存，返回 304，反之则返回资源，并更新 Last-Modified</p><ul><li>文件摘要（ETag）：唯一标识</li></ul><p>有些情况下使用最后修改时间来判断是否改动是不够的 存在周期性重写某些资源，但资源的实际内容并无变化 被修改的信息并不重要，如注释等 Last-Modified 无法精确到毫秒，但有些资源的更新频率小于一秒 为解决这些问题，http 允许用户对资源打上标签(ETag)来区分两个相同路径获取的资源内容是否一致。通常会采用 MD5 等密码散列函数对资源编码得到标签(强验证器)；或者通过版本号等方式，如 W/”v1.0”(W/表示弱验证器) 具体请求过程</p><p>客户端第一次访问服务端资源时，服务端会返回请求的对应资源，并在响应头加上 ETag，这个值是根据资源生成的唯一标识（字符串），只要服务端认为资源有变化，则 ETag 就必须有变化，客户端将资源连同 ETag 一并缓存 当客户端再次请求资源时，会在请求头加上 if-None-Match，值为服务端返回的 ETag 值 服务端收到请求后，会根据请求的资源重新生成 ETag，并跟 if-None-Match 进行比较，若一致则命中缓存，反之返回新资源和新的 ETag</p>',26);function _(f,m,N,C,b,x){const o=a("NolebasePageProperties"),i=a("NolebaseGitContributors"),r=a("NolebaseGitChangelog");return c(),s("div",null,[h,e(o),u,e(i),e(r)])}const T=n(p,[["render",_]]);export{g as __pageData,T as default};
